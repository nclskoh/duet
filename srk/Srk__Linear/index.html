<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml"><head><title>Srk__Linear (srk.Srk__Linear)</title><link rel="stylesheet" href="../../odoc.css"/><meta charset="utf-8"/><meta name="generator" content="odoc 1.5.0"/><meta name="viewport" content="width=device-width,initial-scale=1.0"/><script src="../../highlight.pack.js"></script><script>hljs.initHighlightingOnLoad();</script></head><body><div class="content"><header><nav><a href="../index.html">Up</a> â€“ <a href="../index.html">srk</a> &#x00BB; Srk__Linear</nav><h1>Module <code>Srk__Linear</code></h1><p>Various operations for the vector space <code>int -&gt; QQ</code></p><nav class="toc"><ul><li><a href="#affine-terms">Affine terms</a></li></ul></nav></header><dl><dt class="spec exception" id="exception-No_solution"><a href="#exception-No_solution" class="anchor"></a><code><span class="keyword">exception</span> </code><code><span class="exception">No_solution</span></code></dt><dd><p>Raised for unsolvable systems of linear equations</p></dd></dl><dl><dt class="spec exception" id="exception-Nonlinear"><a href="#exception-Nonlinear" class="anchor"></a><code><span class="keyword">exception</span> </code><code><span class="exception">Nonlinear</span></code></dt></dl><dl><dt class="spec module" id="module-ZZVector"><a href="#module-ZZVector" class="anchor"></a><code><span class="keyword">module</span> <a href="ZZVector/index.html">ZZVector</a> : <span class="keyword">sig</span> ... <span class="keyword">end</span></code></dt><dd><p>Sparse vector with integer entries.</p></dd></dl><dl><dt class="spec module" id="module-QQVector"><a href="#module-QQVector" class="anchor"></a><code><span class="keyword">module</span> <a href="QQVector/index.html">QQVector</a> : <span class="keyword">sig</span> ... <span class="keyword">end</span></code></dt><dd><p>Sparse vector with rational entries.</p></dd></dl><dl><dt class="spec module" id="module-QQMatrix"><a href="#module-QQMatrix" class="anchor"></a><code><span class="keyword">module</span> <a href="QQMatrix/index.html">QQMatrix</a> : <span class="keyword">sig</span> ... <span class="keyword">end</span></code></dt><dd><p>Sparse matrix with rational entries.</p></dd></dl><dl><dt class="spec value" id="val-nullspace"><a href="#val-nullspace" class="anchor"></a><code><span class="keyword">val</span> nullspace : <a href="QQMatrix/index.html#type-t">QQMatrix.t</a> <span>&#45;&gt;</span> <span>int list</span> <span>&#45;&gt;</span> <span><a href="QQVector/index.html#type-t">QQVector.t</a> list</span></code></dt><dd><p><code>nullspace mat dimensions</code> computes a basis for the vector space <code>{ x :
    mat*x = 0}</code>, projected on to the set of dimensions <code>dimensions</code>. (Note that the nullspace is not finitely generated in <code>int -&gt; QQ</code>, hence the projection).</p></dd></dl><dl><dt class="spec value" id="val-solve_exn"><a href="#val-solve_exn" class="anchor"></a><code><span class="keyword">val</span> solve_exn : <a href="QQMatrix/index.html#type-t">QQMatrix.t</a> <span>&#45;&gt;</span> <a href="QQVector/index.html#type-t">QQVector.t</a> <span>&#45;&gt;</span> <a href="QQVector/index.html#type-t">QQVector.t</a></code></dt><dd><p><code>solve_exn mat b</code> computes a rational vector <code>x</code> such that <code>mat*x =
    b</code>. Raises <code>No_solution</code> if there is no solution.</p></dd></dl><dl><dt class="spec value" id="val-solve"><a href="#val-solve" class="anchor"></a><code><span class="keyword">val</span> solve : <a href="QQMatrix/index.html#type-t">QQMatrix.t</a> <span>&#45;&gt;</span> <a href="QQVector/index.html#type-t">QQVector.t</a> <span>&#45;&gt;</span> <span><a href="QQVector/index.html#type-t">QQVector.t</a> option</span></code></dt><dd><p><code>solve mat b</code> computes a rational vector <code>x</code> such that <code>mat*x = b</code>, if such a vector exists. Otherwise, return <code>None</code>.</p></dd></dl><dl><dt class="spec value" id="val-vector_right_mul"><a href="#val-vector_right_mul" class="anchor"></a><code><span class="keyword">val</span> vector_right_mul : <a href="QQMatrix/index.html#type-t">QQMatrix.t</a> <span>&#45;&gt;</span> <a href="QQVector/index.html#type-t">QQVector.t</a> <span>&#45;&gt;</span> <a href="QQVector/index.html#type-t">QQVector.t</a></code></dt><dd><p><code>vector_right_mul m v</code> computes <code>m*v</code></p></dd></dl><dl><dt class="spec value" id="val-vector_left_mul"><a href="#val-vector_left_mul" class="anchor"></a><code><span class="keyword">val</span> vector_left_mul : <a href="QQVector/index.html#type-t">QQVector.t</a> <span>&#45;&gt;</span> <a href="QQMatrix/index.html#type-t">QQMatrix.t</a> <span>&#45;&gt;</span> <a href="QQVector/index.html#type-t">QQVector.t</a></code></dt><dd><p><code>vector_left_mul v m</code> computes <code>(v^t)*m</code></p></dd></dl><dl><dt class="spec value" id="val-intersect_rowspace"><a href="#val-intersect_rowspace" class="anchor"></a><code><span class="keyword">val</span> intersect_rowspace : <a href="QQMatrix/index.html#type-t">QQMatrix.t</a> <span>&#45;&gt;</span> <a href="QQMatrix/index.html#type-t">QQMatrix.t</a> <span>&#45;&gt;</span> <a href="QQMatrix/index.html#type-t">QQMatrix.t</a> * <a href="QQMatrix/index.html#type-t">QQMatrix.t</a></code></dt><dd><p>Given two matrices <code>A</code> and <code>B</code>, compute matrices <code>C</code> and <code>D</code> such that <code>CA
    = DB</code> is a basis for the intersection of the rowspaces of <code>A</code> and <code>B</code>.</p></dd></dl><dl><dt class="spec value" id="val-pushout"><a href="#val-pushout" class="anchor"></a><code><span class="keyword">val</span> pushout : <a href="QQMatrix/index.html#type-t">QQMatrix.t</a> <span>&#45;&gt;</span> <a href="QQMatrix/index.html#type-t">QQMatrix.t</a> <span>&#45;&gt;</span> <a href="QQMatrix/index.html#type-t">QQMatrix.t</a> * <a href="QQMatrix/index.html#type-t">QQMatrix.t</a></code></dt><dd><p>Given two matrices <code>A</code> and <code>B</code>, compute matrices <code>C</code> and <code>D</code> such that <code>CA = DB</code>, and for any <code>E</code> and <code>F</code> such that <code>EA = FB</code>, there exists a (unique) <code>U</code> such that <code>UCA = EA (= UDB = FB)</code></p></dd></dl><dl><dt class="spec value" id="val-divide_right"><a href="#val-divide_right" class="anchor"></a><code><span class="keyword">val</span> divide_right : <a href="QQMatrix/index.html#type-t">QQMatrix.t</a> <span>&#45;&gt;</span> <a href="QQMatrix/index.html#type-t">QQMatrix.t</a> <span>&#45;&gt;</span> <span><a href="QQMatrix/index.html#type-t">QQMatrix.t</a> option</span></code></dt><dd><p>Given two matrices A and B, compute a matrix C such that CB = A (if one exists). C exists when the rowspace of B is contained in the rowspace of A. If A and B are invertible, then C is exactly AB<sup>-1</sup>.</p></dd></dl><dl><dt class="spec value" id="val-divide_left"><a href="#val-divide_left" class="anchor"></a><code><span class="keyword">val</span> divide_left : <a href="QQMatrix/index.html#type-t">QQMatrix.t</a> <span>&#45;&gt;</span> <a href="QQMatrix/index.html#type-t">QQMatrix.t</a> <span>&#45;&gt;</span> <span><a href="QQMatrix/index.html#type-t">QQMatrix.t</a> option</span></code></dt><dd><p>Given two matrices A and B, compute a matrix C such that BC = A (if one exists). C exists when the columnspace of B is contained in the columnspace of A. If A and B are invertible, then C is exactly B<sup>-1</sup>A.</p></dd></dl><dl><dt class="spec value" id="val-rational_spectral_decomposition"><a href="#val-rational_spectral_decomposition" class="anchor"></a><code><span class="keyword">val</span> rational_spectral_decomposition : <a href="QQMatrix/index.html#type-t">QQMatrix.t</a> <span>&#45;&gt;</span> <span>int list</span> <span>&#45;&gt;</span> <span><span>(<a href="../Srk/QQ/index.html#type-t">Srk.QQ.t</a> * <a href="QQVector/index.html#type-t">QQVector.t</a>)</span> list</span></code></dt><dd><p>Compute a list of (rational eigenvalue, generalized eigenvector) pairs of a finite dimensional square submatrix of a given matrix. The submatrix is determined by the list of dimensions given as the second parameter.</p></dd></dl><dl><dt class="spec value" id="val-periodic_rational_spectral_decomposition"><a href="#val-periodic_rational_spectral_decomposition" class="anchor"></a><code><span class="keyword">val</span> periodic_rational_spectral_decomposition : <a href="QQMatrix/index.html#type-t">QQMatrix.t</a> <span>&#45;&gt;</span> <span>int list</span> <span>&#45;&gt;</span> <span><span>(int * <a href="../Srk/QQ/index.html#type-t">Srk.QQ.t</a> * <a href="QQVector/index.html#type-t">QQVector.t</a>)</span> list</span></code></dt><dd><p>Compute a list of (period, rational eigenvalue, generalized eigenvector) triples of a finite dimensional square submatrix of a given matrix. The submatrix is determined by the list of dimensions given as the second parameter.</p></dd></dl><dl><dt class="spec value" id="val-jordan_chain"><a href="#val-jordan_chain" class="anchor"></a><code><span class="keyword">val</span> jordan_chain : <a href="QQMatrix/index.html#type-t">QQMatrix.t</a> <span>&#45;&gt;</span> <a href="../Srk/QQ/index.html#type-t">Srk.QQ.t</a> <span>&#45;&gt;</span> <a href="QQVector/index.html#type-t">QQVector.t</a> <span>&#45;&gt;</span> <span><a href="QQVector/index.html#type-t">QQVector.t</a> list</span></code></dt><dd><p><code>jordan_chain mA lambda v</code> computes the (left) Jordan chain generated by <code>v</code> corresponding to the eigenvalue <code>lambda</code> of <code>mA</code>. This is a list of vectors v<sub>0</sub>,...,v<sub>n</sub> such that</p><ul><li>v<sub>0</sub> = v</li><li>for each i &lt; n we have v<sub>i</sub>(mA-lambda*I) = v<sub><i>+1</i></sub></li><li>v<sub>n</sub>(mA-lambda*I) = 0</li></ul></dd></dl><dl><dt class="spec module" id="module-QQVectorSpace"><a href="#module-QQVectorSpace" class="anchor"></a><code><span class="keyword">module</span> <a href="QQVectorSpace/index.html">QQVectorSpace</a> : <span class="keyword">sig</span> ... <span class="keyword">end</span></code></dt><dd></dd></dl><section><header><h3 id="affine-terms"><a href="#affine-terms" class="anchor"></a>Affine terms</h3></header><aside><p>Various operations for manipulating affine terms over symbols, represented as rational vectors</p></aside><dl><dt class="spec value" id="val-sym_of_dim"><a href="#val-sym_of_dim" class="anchor"></a><code><span class="keyword">val</span> sym_of_dim : int <span>&#45;&gt;</span> <span><a href="../Srk/Syntax/index.html#type-symbol">Srk.Syntax.symbol</a> option</span></code></dt><dd><p>Map a symbol to a dimension. The following equations hold:</p><ul><li><code>sym_of_dim (dim_of_sym sym) = Some sym</code></li><li><code>sym_of_dim const_dim = None</code></li></ul></dd></dl><dl><dt class="spec value" id="val-dim_of_sym"><a href="#val-dim_of_sym" class="anchor"></a><code><span class="keyword">val</span> dim_of_sym : <a href="../Srk/Syntax/index.html#type-symbol">Srk.Syntax.symbol</a> <span>&#45;&gt;</span> int</code></dt><dd><p>Map a dimension to symbol. The following equations hold:</p><ul><li><code>sym_of_dim (dim_of_sym sym) = Some sym</code></li><li><code>sym_of_dim const_dim = None</code></li></ul></dd></dl><dl><dt class="spec value" id="val-const_dim"><a href="#val-const_dim" class="anchor"></a><code><span class="keyword">val</span> const_dim : int</code></dt><dd><p>Dimension for representing the coefficient of the constant 1.</p></dd></dl><dl><dt class="spec value" id="val-const_linterm"><a href="#val-const_linterm" class="anchor"></a><code><span class="keyword">val</span> const_linterm : <a href="../Srk/QQ/index.html#type-t">Srk.QQ.t</a> <span>&#45;&gt;</span> <a href="QQVector/index.html#type-t">QQVector.t</a></code></dt><dd><p>Representation of a rational number as an affine term. The equation <code>const_of_linterm (const_linterm qq) = Some qq</code> must hold.</p></dd></dl><dl><dt class="spec value" id="val-const_of_linterm"><a href="#val-const_of_linterm" class="anchor"></a><code><span class="keyword">val</span> const_of_linterm : <a href="QQVector/index.html#type-t">QQVector.t</a> <span>&#45;&gt;</span> <span><a href="../Srk/QQ/index.html#type-t">Srk.QQ.t</a> option</span></code></dt><dd><p>Convert an affine term to a rational number, if possible. The equation <code>const_of_linterm (const_linterm qq) = Some qq</code> must hold.</p></dd></dl><dl><dt class="spec value" id="val-linterm_of"><a href="#val-linterm_of" class="anchor"></a><code><span class="keyword">val</span> linterm_of : <span><span class="type-var">'a</span> <a href="../Srk/Syntax/index.html#type-context">Srk.Syntax.context</a></span> <span>&#45;&gt;</span> <span><span class="type-var">'a</span> <a href="../Srk/Syntax/index.html#type-term">Srk.Syntax.term</a></span> <span>&#45;&gt;</span> <a href="QQVector/index.html#type-t">QQVector.t</a></code></dt><dd><p>Convert a rational vector representing an affine term. Raises <code>Nonlinear</code> if the input term is non-linear.</p></dd></dl><dl><dt class="spec value" id="val-of_linterm"><a href="#val-of_linterm" class="anchor"></a><code><span class="keyword">val</span> of_linterm : <span><span class="type-var">'a</span> <a href="../Srk/Syntax/index.html#type-context">Srk.Syntax.context</a></span> <span>&#45;&gt;</span> <a href="QQVector/index.html#type-t">QQVector.t</a> <span>&#45;&gt;</span> <span><span class="type-var">'a</span> <a href="../Srk/Syntax/index.html#type-term">Srk.Syntax.term</a></span></code></dt><dd><p>Convert a rational vector to an affine term. The equation <code>of_linterm srk
    (linterm_of srk t) = t</code> must hold.</p></dd></dl><dl><dt class="spec value" id="val-pp_linterm"><a href="#val-pp_linterm" class="anchor"></a><code><span class="keyword">val</span> pp_linterm : <span><span class="type-var">'a</span> <a href="../Srk/Syntax/index.html#type-context">Srk.Syntax.context</a></span> <span>&#45;&gt;</span> Stdlib.Format.formatter <span>&#45;&gt;</span> <a href="QQVector/index.html#type-t">QQVector.t</a> <span>&#45;&gt;</span> unit</code></dt><dd><p>Pretty-print an affine term</p></dd></dl><dl><dt class="spec value" id="val-evaluate_linterm"><a href="#val-evaluate_linterm" class="anchor"></a><code><span class="keyword">val</span> evaluate_linterm : <span>(<a href="../Srk/Syntax/index.html#type-symbol">Srk.Syntax.symbol</a> <span>&#45;&gt;</span> <a href="../Srk/QQ/index.html#type-t">Srk.QQ.t</a>)</span> <span>&#45;&gt;</span> <a href="QQVector/index.html#type-t">QQVector.t</a> <span>&#45;&gt;</span> <a href="../Srk/QQ/index.html#type-t">Srk.QQ.t</a></code></dt><dd><p><code>evaluate_linterm env t</code> evaluates the affine term t in the environment <code>env</code></p></dd></dl><dl><dt class="spec value" id="val-linterm_size"><a href="#val-linterm_size" class="anchor"></a><code><span class="keyword">val</span> linterm_size : <a href="QQVector/index.html#type-t">QQVector.t</a> <span>&#45;&gt;</span> int</code></dt><dd><p>Count the number of dimensions with non-zero coefficients</p></dd></dl><dl><dt class="spec value" id="val-term_of_vec"><a href="#val-term_of_vec" class="anchor"></a><code><span class="keyword">val</span> term_of_vec : <span><span class="type-var">'a</span> <a href="../Srk/Syntax/index.html#type-context">Srk.Syntax.context</a></span> <span>&#45;&gt;</span> <span>(int <span>&#45;&gt;</span> <span><span class="type-var">'a</span> <a href="../Srk/Syntax/index.html#type-term">Srk.Syntax.term</a></span>)</span> <span>&#45;&gt;</span> <a href="QQVector/index.html#type-t">QQVector.t</a> <span>&#45;&gt;</span> <span><span class="type-var">'a</span> <a href="../Srk/Syntax/index.html#type-term">Srk.Syntax.term</a></span></code></dt><dd><p><code>term_of_vec srk t vec</code> creates a term representation of <code>vec</code> by interpreting each dimension i as the term <code>t i</code>.</p></dd></dl><dl><dt class="spec value" id="val-evaluate_affine"><a href="#val-evaluate_affine" class="anchor"></a><code><span class="keyword">val</span> evaluate_affine : <span>(int <span>&#45;&gt;</span> <a href="../Srk/QQ/index.html#type-t">Srk.QQ.t</a>)</span> <span>&#45;&gt;</span> <a href="QQVector/index.html#type-t">QQVector.t</a> <span>&#45;&gt;</span> <a href="../Srk/QQ/index.html#type-t">Srk.QQ.t</a></code></dt><dd><p>Evaluate a vector by interpreting each coordinate according to the given interpretation (the interpretation of <code>const_dim</code> is fixed to be 1).</p></dd></dl></section></div></body></html>