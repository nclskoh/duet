<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml"><head><title>WeightedGraph (srk.Srk.WeightedGraph)</title><link rel="stylesheet" href="../../../odoc.css"/><meta charset="utf-8"/><meta name="generator" content="odoc 1.5.0"/><meta name="viewport" content="width=device-width,initial-scale=1.0"/><script src="../../../highlight.pack.js"></script><script>hljs.initHighlightingOnLoad();</script></head><body><div class="content"><header><nav><a href="../index.html">Up</a> – <a href="../../index.html">srk</a> &#x00BB; <a href="../index.html">Srk</a> &#x00BB; WeightedGraph</nav><h1>Module <code>Srk.WeightedGraph</code></h1></header><aside><p>Operations for manipulating weighted graphs.</p><p>A weighted graph is a graph where edges are labeled by elements of a regular algebra.</p></aside><dl><dt class="spec type" id="type-weighted_graph"><a href="#type-weighted_graph" class="anchor"></a><code><span class="keyword">type</span> <span>'a weighted_graph</span></code></dt><dt class="spec type" id="type-t"><a href="#type-t" class="anchor"></a><code><span class="keyword">type</span> <span>'a t</span></code><code> = <span><span class="type-var">'a</span> <a href="index.html#type-weighted_graph">weighted_graph</a></span></code></dt><dt class="spec type" id="type-algebra"><a href="#type-algebra" class="anchor"></a><code><span class="keyword">type</span> <span>'a algebra</span></code><code> = </code><code>{</code><table class="record"><tr id="type-algebra.mul" class="anchored"><td class="def field"><a href="#type-algebra.mul" class="anchor"></a><code>mul : <span class="type-var">'a</span> <span>&#45;&gt;</span> <span class="type-var">'a</span> <span>&#45;&gt;</span> <span class="type-var">'a</span>;</code></td></tr><tr id="type-algebra.add" class="anchored"><td class="def field"><a href="#type-algebra.add" class="anchor"></a><code>add : <span class="type-var">'a</span> <span>&#45;&gt;</span> <span class="type-var">'a</span> <span>&#45;&gt;</span> <span class="type-var">'a</span>;</code></td></tr><tr id="type-algebra.star" class="anchored"><td class="def field"><a href="#type-algebra.star" class="anchor"></a><code>star : <span class="type-var">'a</span> <span>&#45;&gt;</span> <span class="type-var">'a</span>;</code></td></tr><tr id="type-algebra.zero" class="anchored"><td class="def field"><a href="#type-algebra.zero" class="anchor"></a><code>zero : <span class="type-var">'a</span>;</code></td></tr><tr id="type-algebra.one" class="anchored"><td class="def field"><a href="#type-algebra.one" class="anchor"></a><code>one : <span class="type-var">'a</span>;</code></td></tr></table><code>}</code></dt><dd><p>Regular algebra signature</p></dd></dl><dl><dt class="spec type" id="type-omega_algebra"><a href="#type-omega_algebra" class="anchor"></a><code><span class="keyword">type</span> <span>('a, 'b) omega_algebra</span></code><code> = </code><code>{</code><table class="record"><tr id="type-omega_algebra.omega" class="anchored"><td class="def field"><a href="#type-omega_algebra.omega" class="anchor"></a><code>omega : <span class="type-var">'a</span> <span>&#45;&gt;</span> <span class="type-var">'b</span>;</code></td></tr><tr id="type-omega_algebra.omega_add" class="anchored"><td class="def field"><a href="#type-omega_algebra.omega_add" class="anchor"></a><code>omega_add : <span class="type-var">'b</span> <span>&#45;&gt;</span> <span class="type-var">'b</span> <span>&#45;&gt;</span> <span class="type-var">'b</span>;</code></td></tr><tr id="type-omega_algebra.omega_mul" class="anchored"><td class="def field"><a href="#type-omega_algebra.omega_mul" class="anchor"></a><code>omega_mul : <span class="type-var">'a</span> <span>&#45;&gt;</span> <span class="type-var">'b</span> <span>&#45;&gt;</span> <span class="type-var">'b</span>;</code></td></tr></table><code>}</code></dt><dd><p>Omega algebra signature</p></dd></dl><dl><dt class="spec module" id="module-U"><a href="#module-U" class="anchor"></a><code><span class="keyword">module</span> U : Graph.Sig.G <span class="keyword">with</span> <span class="keyword">type</span> <a href="index.html#module-U">U</a>.V.t = int</code></dt><dd><p>Unweighted graphs</p></dd></dl><dl><dt class="spec type" id="type-vertex"><a href="#type-vertex" class="anchor"></a><code><span class="keyword">type</span> vertex</code><code> = int</code></dt></dl><dl><dt class="spec value" id="val-empty"><a href="#val-empty" class="anchor"></a><code><span class="keyword">val</span> empty : <span><span class="type-var">'a</span> <a href="index.html#type-algebra">algebra</a></span> <span>&#45;&gt;</span> <span><span class="type-var">'a</span> <a href="index.html#type-t">t</a></span></code></dt><dd><p>Create an empty weighted graph over the given algebra of weights.</p></dd></dl><dl><dt class="spec value" id="val-add_vertex"><a href="#val-add_vertex" class="anchor"></a><code><span class="keyword">val</span> add_vertex : <span><span class="type-var">'a</span> <a href="index.html#type-t">t</a></span> <span>&#45;&gt;</span> <a href="index.html#type-vertex">vertex</a> <span>&#45;&gt;</span> <span><span class="type-var">'a</span> <a href="index.html#type-t">t</a></span></code></dt><dd><p>Add a vertex to a graph.</p></dd></dl><dl><dt class="spec value" id="val-add_edge"><a href="#val-add_edge" class="anchor"></a><code><span class="keyword">val</span> add_edge : <span><span class="type-var">'a</span> <a href="index.html#type-t">t</a></span> <span>&#45;&gt;</span> <a href="index.html#type-vertex">vertex</a> <span>&#45;&gt;</span> <span class="type-var">'a</span> <span>&#45;&gt;</span> <a href="index.html#type-vertex">vertex</a> <span>&#45;&gt;</span> <span><span class="type-var">'a</span> <a href="index.html#type-t">t</a></span></code></dt><dd><p><code>add_edge g u w v</code> adds an edge <code>u -w-&gt; v</code> to <code>g</code>. If there is already an edge from <code>u</code> to <code>v</code>, then <code>w</code> is added to the weight of the edge.</p></dd></dl><dl><dt class="spec value" id="val-edge_weight"><a href="#val-edge_weight" class="anchor"></a><code><span class="keyword">val</span> edge_weight : <span><span class="type-var">'a</span> <a href="index.html#type-t">t</a></span> <span>&#45;&gt;</span> <a href="index.html#type-vertex">vertex</a> <span>&#45;&gt;</span> <a href="index.html#type-vertex">vertex</a> <span>&#45;&gt;</span> <span class="type-var">'a</span></code></dt><dd><p>Find the weight associated with a single edge.</p></dd></dl><dl><dt class="spec value" id="val-path_weight"><a href="#val-path_weight" class="anchor"></a><code><span class="keyword">val</span> path_weight : <span><span class="type-var">'a</span> <a href="index.html#type-t">t</a></span> <span>&#45;&gt;</span> <a href="index.html#type-vertex">vertex</a> <span>&#45;&gt;</span> <a href="index.html#type-vertex">vertex</a> <span>&#45;&gt;</span> <span class="type-var">'a</span></code></dt><dd><p><code>path_weight g u v</code> computes the sum of all weighted paths from <code>u</code> to <code>v</code> in <code>g</code>.</p></dd></dl><dl><dt class="spec value" id="val-msat_path_weight"><a href="#val-msat_path_weight" class="anchor"></a><code><span class="keyword">val</span> msat_path_weight : <span><span class="type-var">'a</span> <a href="index.html#type-t">t</a></span> <span>&#45;&gt;</span> <span><a href="index.html#type-vertex">vertex</a> list</span> <span>&#45;&gt;</span> <span><span class="type-var">'a</span> <a href="index.html#type-t">t</a></span></code></dt><dd><p>Multiple-source all-target path expressions. <code>msat_path_weight g
   srcs</code> computes a function <code>f</code> which maps a vertex <code>u</code> belonging to <code>src</code> and any other vertex <code>v</code> to to the sum of all weighted paths from <code>u</code> to <code>v</code>.</p></dd></dl><dl><dt class="spec value" id="val-omega_path_weight"><a href="#val-omega_path_weight" class="anchor"></a><code><span class="keyword">val</span> omega_path_weight : <span><span class="type-var">'a</span> <a href="index.html#type-t">t</a></span> <span>&#45;&gt;</span> <span><span>(<span class="type-var">'a</span>, <span class="type-var">'b</span>)</span> <a href="index.html#type-omega_algebra">omega_algebra</a></span> <span>&#45;&gt;</span> <a href="index.html#type-vertex">vertex</a> <span>&#45;&gt;</span> <span class="type-var">'b</span></code></dt><dd><p><code>omega_path_weight g alg v</code> computes the sum of all weighted omega paths starting at <code>v</code> in <code>g</code>.</p></dd></dl><dl><dt class="spec value" id="val-cut_graph"><a href="#val-cut_graph" class="anchor"></a><code><span class="keyword">val</span> cut_graph : <span><span class="type-var">'a</span> <a href="index.html#type-t">t</a></span> <span>&#45;&gt;</span> <span><a href="index.html#type-vertex">vertex</a> list</span> <span>&#45;&gt;</span> <span><span class="type-var">'a</span> <a href="index.html#type-t">t</a></span></code></dt><dd><p><code>cut_graph g c</code> computes the cut graph g' g' = &lt;c, { (u, w, v) : (u, v) in c x c, w is the sum of all paths from u to v in g not going through any node in c }&gt; *</p></dd></dl><dl><dt class="spec value" id="val-remove_vertex"><a href="#val-remove_vertex" class="anchor"></a><code><span class="keyword">val</span> remove_vertex : <span><span class="type-var">'a</span> <a href="index.html#type-t">t</a></span> <span>&#45;&gt;</span> <a href="index.html#type-vertex">vertex</a> <span>&#45;&gt;</span> <span><span class="type-var">'a</span> <a href="index.html#type-t">t</a></span></code></dt><dd><p>Remove a vertex from a graph.</p></dd></dl><dl><dt class="spec value" id="val-contract_vertex"><a href="#val-contract_vertex" class="anchor"></a><code><span class="keyword">val</span> contract_vertex : <span><span class="type-var">'a</span> <a href="index.html#type-t">t</a></span> <span>&#45;&gt;</span> <a href="index.html#type-vertex">vertex</a> <span>&#45;&gt;</span> <span><span class="type-var">'a</span> <a href="index.html#type-t">t</a></span></code></dt><dd><p><code>contract g v</code> removes vertex <code>v</code> from <code>g</code> while preserving all weighted paths among remaining vertices. That is, for each pair of edges <code>p -pw-&gt;
    v</code> and <code>v -sw-&gt; s</code>, adds the edge <code>p -&gt; s</code> with weight <code>pw.vw*.sw</code>, where <code>vw</code> is the weight of the self-loop at <code>v</code>.</p></dd></dl><dl><dt class="spec value" id="val-split_vertex"><a href="#val-split_vertex" class="anchor"></a><code><span class="keyword">val</span> split_vertex : <span><span class="type-var">'a</span> <a href="index.html#type-t">t</a></span> <span>&#45;&gt;</span> <a href="index.html#type-vertex">vertex</a> <span>&#45;&gt;</span> <span class="type-var">'a</span> <span>&#45;&gt;</span> <a href="index.html#type-vertex">vertex</a> <span>&#45;&gt;</span> <span><span class="type-var">'a</span> <a href="index.html#type-t">t</a></span></code></dt><dt class="spec value" id="val-forget_weights"><a href="#val-forget_weights" class="anchor"></a><code><span class="keyword">val</span> forget_weights : <span><span class="type-var">'a</span> <a href="index.html#type-t">t</a></span> <span>&#45;&gt;</span> <a href="index.html#module-U">U</a>.t</code></dt><dt class="spec value" id="val-map_weights"><a href="#val-map_weights" class="anchor"></a><code><span class="keyword">val</span> map_weights : <span>(<a href="index.html#type-vertex">vertex</a> <span>&#45;&gt;</span> <span class="type-var">'a</span> <span>&#45;&gt;</span> <a href="index.html#type-vertex">vertex</a> <span>&#45;&gt;</span> <span class="type-var">'a</span>)</span> <span>&#45;&gt;</span> <span><span class="type-var">'a</span> <a href="index.html#type-t">t</a></span> <span>&#45;&gt;</span> <span><span class="type-var">'a</span> <a href="index.html#type-t">t</a></span></code></dt><dt class="spec value" id="val-fold_edges"><a href="#val-fold_edges" class="anchor"></a><code><span class="keyword">val</span> fold_edges : <span>(<span>(<a href="index.html#type-vertex">vertex</a> * <span class="type-var">'a</span> * <a href="index.html#type-vertex">vertex</a>)</span> <span>&#45;&gt;</span> <span class="type-var">'b</span> <span>&#45;&gt;</span> <span class="type-var">'b</span>)</span> <span>&#45;&gt;</span> <span><span class="type-var">'a</span> <a href="index.html#type-t">t</a></span> <span>&#45;&gt;</span> <span class="type-var">'b</span> <span>&#45;&gt;</span> <span class="type-var">'b</span></code></dt><dt class="spec value" id="val-iter_edges"><a href="#val-iter_edges" class="anchor"></a><code><span class="keyword">val</span> iter_edges : <span>(<span>(<a href="index.html#type-vertex">vertex</a> * <span class="type-var">'a</span> * <a href="index.html#type-vertex">vertex</a>)</span> <span>&#45;&gt;</span> unit)</span> <span>&#45;&gt;</span> <span><span class="type-var">'a</span> <a href="index.html#type-t">t</a></span> <span>&#45;&gt;</span> unit</code></dt><dt class="spec value" id="val-fold_succ_e"><a href="#val-fold_succ_e" class="anchor"></a><code><span class="keyword">val</span> fold_succ_e : <span>(<span>(<a href="index.html#type-vertex">vertex</a> * <span class="type-var">'a</span> * <a href="index.html#type-vertex">vertex</a>)</span> <span>&#45;&gt;</span> <span class="type-var">'b</span> <span>&#45;&gt;</span> <span class="type-var">'b</span>)</span> <span>&#45;&gt;</span> <span><span class="type-var">'a</span> <a href="index.html#type-t">t</a></span> <span>&#45;&gt;</span> <a href="index.html#type-vertex">vertex</a> <span>&#45;&gt;</span> <span class="type-var">'b</span> <span>&#45;&gt;</span> <span class="type-var">'b</span></code></dt><dt class="spec value" id="val-fold_pred_e"><a href="#val-fold_pred_e" class="anchor"></a><code><span class="keyword">val</span> fold_pred_e : <span>(<span>(<a href="index.html#type-vertex">vertex</a> * <span class="type-var">'a</span> * <a href="index.html#type-vertex">vertex</a>)</span> <span>&#45;&gt;</span> <span class="type-var">'b</span> <span>&#45;&gt;</span> <span class="type-var">'b</span>)</span> <span>&#45;&gt;</span> <span><span class="type-var">'a</span> <a href="index.html#type-t">t</a></span> <span>&#45;&gt;</span> <a href="index.html#type-vertex">vertex</a> <span>&#45;&gt;</span> <span class="type-var">'b</span> <span>&#45;&gt;</span> <span class="type-var">'b</span></code></dt><dt class="spec value" id="val-iter_succ_e"><a href="#val-iter_succ_e" class="anchor"></a><code><span class="keyword">val</span> iter_succ_e : <span>(<span>(<a href="index.html#type-vertex">vertex</a> * <span class="type-var">'a</span> * <a href="index.html#type-vertex">vertex</a>)</span> <span>&#45;&gt;</span> unit)</span> <span>&#45;&gt;</span> <span><span class="type-var">'a</span> <a href="index.html#type-t">t</a></span> <span>&#45;&gt;</span> <a href="index.html#type-vertex">vertex</a> <span>&#45;&gt;</span> unit</code></dt><dt class="spec value" id="val-iter_pred_e"><a href="#val-iter_pred_e" class="anchor"></a><code><span class="keyword">val</span> iter_pred_e : <span>(<span>(<a href="index.html#type-vertex">vertex</a> * <span class="type-var">'a</span> * <a href="index.html#type-vertex">vertex</a>)</span> <span>&#45;&gt;</span> unit)</span> <span>&#45;&gt;</span> <span><span class="type-var">'a</span> <a href="index.html#type-t">t</a></span> <span>&#45;&gt;</span> <a href="index.html#type-vertex">vertex</a> <span>&#45;&gt;</span> unit</code></dt><dt class="spec value" id="val-fold_vertex"><a href="#val-fold_vertex" class="anchor"></a><code><span class="keyword">val</span> fold_vertex : <span>(<a href="index.html#type-vertex">vertex</a> <span>&#45;&gt;</span> <span class="type-var">'b</span> <span>&#45;&gt;</span> <span class="type-var">'b</span>)</span> <span>&#45;&gt;</span> <span><span class="type-var">'a</span> <a href="index.html#type-t">t</a></span> <span>&#45;&gt;</span> <span class="type-var">'b</span> <span>&#45;&gt;</span> <span class="type-var">'b</span></code></dt><dt class="spec value" id="val-iter_vertex"><a href="#val-iter_vertex" class="anchor"></a><code><span class="keyword">val</span> iter_vertex : <span>(<a href="index.html#type-vertex">vertex</a> <span>&#45;&gt;</span> unit)</span> <span>&#45;&gt;</span> <span><span class="type-var">'a</span> <a href="index.html#type-t">t</a></span> <span>&#45;&gt;</span> unit</code></dt><dt class="spec value" id="val-mem_edge"><a href="#val-mem_edge" class="anchor"></a><code><span class="keyword">val</span> mem_edge : <span><span class="type-var">'a</span> <a href="index.html#type-t">t</a></span> <span>&#45;&gt;</span> <a href="index.html#type-vertex">vertex</a> <span>&#45;&gt;</span> <a href="index.html#type-vertex">vertex</a> <span>&#45;&gt;</span> bool</code></dt><dt class="spec value" id="val-max_vertex"><a href="#val-max_vertex" class="anchor"></a><code><span class="keyword">val</span> max_vertex : <span><span class="type-var">'a</span> <a href="index.html#type-t">t</a></span> <span>&#45;&gt;</span> int</code></dt><dd><p>Find the largest integer identifier for a vertex in a graph</p></dd></dl><dl><dt class="spec value" id="val-forward_analysis"><a href="#val-forward_analysis" class="anchor"></a><code><span class="keyword">val</span> forward_analysis : <span><span class="type-var">'a</span> <a href="index.html#type-t">t</a></span> <span>&#45;&gt;</span> <span>entry:int</span> <span>&#45;&gt;</span> <span>update:<span>(<span>pre:<span class="type-var">'v</span></span> <span>&#45;&gt;</span> <span class="type-var">'a</span> <span>&#45;&gt;</span> <span>post:<span class="type-var">'v</span></span> <span>&#45;&gt;</span> <span><span class="type-var">'v</span> option</span>)</span></span> <span>&#45;&gt;</span> <span>init:<span>(int <span>&#45;&gt;</span> <span class="type-var">'v</span>)</span></span> <span>&#45;&gt;</span> int <span>&#45;&gt;</span> <span class="type-var">'v</span></code></dt><dd><p>Compute least fixpoint solution to a system of constraints defined over a weighted graph. The type <code>'v</code> represents values in poset. We compute the least annotation <code>inv</code> of the graph such that</p><ul><li><code>inv(v) &gt;= init(v)</code> for all vertices <code>v</code></li><li><code>update (inv src) weight (inv dst) = None</code> for each edge (src, weight, dst)</li></ul><p>The update function associates each edge with a constraint. The constraint is satisfied when the update function returns <code>None</code>; otherwise <code>update pre weight post</code> should return the least value <code>post'</code> such that</p><ul><li><code>post' &gt;= post</code></li><li><code>update pre weight post' = None</code> (i.e., <code>post'</code> satisfies the associated constraint)</li></ul><p>The poset <code>'v</code> is expected to satisfy the ascending chain condition, and <code>update</code> is expected to be monotone in the sense that if <code>pre &gt;= pre'</code> and <code>update pre weight post = None</code>, then <code>update pre' weight post = None</code>.</p></dd></dl><div class="spec module-type" id="module-type-AbstractWeight"><a href="#module-type-AbstractWeight" class="anchor"></a><code><span class="keyword">module</span> <span class="keyword">type</span> <a href="module-type-AbstractWeight/index.html">AbstractWeight</a> = <span class="keyword">sig</span> ... <span class="keyword">end</span></code></div><dl><dt class="spec module" id="module-RecGraph"><a href="#module-RecGraph" class="anchor"></a><code><span class="keyword">module</span> <a href="RecGraph/index.html">RecGraph</a> : <span class="keyword">sig</span> ... <span class="keyword">end</span></code></dt><dd><p>A recursive graph is a graph with two types of edges: simple edges and call edges. Each call edge designates an entry vertex and exit vertex, and can be interpreted a set of paths that begin and entry and end at exit.</p></dd></dl></div></body></html>