<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml"><head><title>Pathexpr (srk.Srk.Pathexpr)</title><link rel="stylesheet" href="../../../odoc.css"/><meta charset="utf-8"/><meta name="generator" content="odoc 1.5.0"/><meta name="viewport" content="width=device-width,initial-scale=1.0"/><script src="../../../highlight.pack.js"></script><script>hljs.initHighlightingOnLoad();</script></head><body><div class="content"><header><nav><a href="../index.html">Up</a> â€“ <a href="../../index.html">srk</a> &#x00BB; <a href="../index.html">Srk</a> &#x00BB; Pathexpr</nav><h1>Module <code>Srk.Pathexpr</code></h1><nav class="toc"><ul><li><a href="#path-expressions">Path expressions</a><ul><li><a href="#constructors">Constructors</a></li><li><a href="#evaluation">Evaluation</a></li></ul></li><li><a href="#omega-path-expressions">Omega path expressions</a><ul><li><a href="#constructors">Constructors</a></li><li><a href="#evaluation">Evaluation</a></li></ul></li></ul></nav></header><section><header><h2 id="path-expressions"><a href="#path-expressions" class="anchor"></a>Path expressions</h2></header><dl><dt class="spec type" id="type-simple"><a href="#type-simple" class="anchor"></a><code><span class="keyword">type</span> simple</code></dt><dt class="spec type" id="type-nested"><a href="#type-nested" class="anchor"></a><code><span class="keyword">type</span> nested</code></dt><dt class="spec type" id="type-t"><a href="#type-t" class="anchor"></a><code><span class="keyword">type</span> <span>'a t</span></code></dt><dd><p>A simple path expression for a graph <code>G</code> is a regular expression over the alphabet of the edges of <code>G</code>, in which every recognized word is a finite path in <code>G</code>. A nested path expression is a simple path expression extended with a Segment operator, which is used to group sub-expressions; nested path expressions recognize nested paths, which are paths equipped with nested grouping structure.</p></dd></dl><dl><dt class="spec type" id="type-context"><a href="#type-context" class="anchor"></a><code><span class="keyword">type</span> context</code></dt><dd><p>Context for managing path expressions</p></dd></dl><dl><dt class="spec value" id="val-pp"><a href="#val-pp" class="anchor"></a><code><span class="keyword">val</span> pp : Stdlib.Format.formatter <span>&#45;&gt;</span> <span><span class="type-var">'a</span> <a href="index.html#type-t">t</a></span> <span>&#45;&gt;</span> unit</code></dt><dt class="spec value" id="val-show"><a href="#val-show" class="anchor"></a><code><span class="keyword">val</span> show : <span><span class="type-var">'a</span> <a href="index.html#type-t">t</a></span> <span>&#45;&gt;</span> string</code></dt><dt class="spec value" id="val-mk_context"><a href="#val-mk_context" class="anchor"></a><code><span class="keyword">val</span> mk_context : <span>?&#8288;size:int</span> <span>&#45;&gt;</span> unit <span>&#45;&gt;</span> <a href="index.html#type-context">context</a></code></dt><dd><p>Create a new path expression context, with a given (optional) table size for hashconsed path expressions.</p></dd></dl><dl><dt class="spec value" id="val-equiv"><a href="#val-equiv" class="anchor"></a><code><span class="keyword">val</span> equiv : <a href="index.html#type-context">context</a> <span>&#45;&gt;</span> <span><a href="index.html#type-simple">simple</a> <a href="index.html#type-t">t</a></span> <span>&#45;&gt;</span> <span><a href="index.html#type-simple">simple</a> <a href="index.html#type-t">t</a></span> <span>&#45;&gt;</span> bool</code></dt><dd><p>Check whether two path expressions recognize the same language</p></dd></dl><section><header><h3 id="constructors"><a href="#constructors" class="anchor"></a>Constructors</h3></header><dl><dt class="spec value" id="val-mk_mul"><a href="#val-mk_mul" class="anchor"></a><code><span class="keyword">val</span> mk_mul : <a href="index.html#type-context">context</a> <span>&#45;&gt;</span> <span><span class="type-var">'a</span> <a href="index.html#type-t">t</a></span> <span>&#45;&gt;</span> <span><span class="type-var">'a</span> <a href="index.html#type-t">t</a></span> <span>&#45;&gt;</span> <span><span class="type-var">'a</span> <a href="index.html#type-t">t</a></span></code></dt><dt class="spec value" id="val-mk_add"><a href="#val-mk_add" class="anchor"></a><code><span class="keyword">val</span> mk_add : <a href="index.html#type-context">context</a> <span>&#45;&gt;</span> <span><span class="type-var">'a</span> <a href="index.html#type-t">t</a></span> <span>&#45;&gt;</span> <span><span class="type-var">'a</span> <a href="index.html#type-t">t</a></span> <span>&#45;&gt;</span> <span><span class="type-var">'a</span> <a href="index.html#type-t">t</a></span></code></dt><dt class="spec value" id="val-mk_zero"><a href="#val-mk_zero" class="anchor"></a><code><span class="keyword">val</span> mk_zero : <a href="index.html#type-context">context</a> <span>&#45;&gt;</span> <span><span class="type-var">'a</span> <a href="index.html#type-t">t</a></span></code></dt><dt class="spec value" id="val-mk_one"><a href="#val-mk_one" class="anchor"></a><code><span class="keyword">val</span> mk_one : <a href="index.html#type-context">context</a> <span>&#45;&gt;</span> <span><span class="type-var">'a</span> <a href="index.html#type-t">t</a></span></code></dt><dt class="spec value" id="val-mk_star"><a href="#val-mk_star" class="anchor"></a><code><span class="keyword">val</span> mk_star : <a href="index.html#type-context">context</a> <span>&#45;&gt;</span> <span><span class="type-var">'a</span> <a href="index.html#type-t">t</a></span> <span>&#45;&gt;</span> <span><span class="type-var">'a</span> <a href="index.html#type-t">t</a></span></code></dt><dt class="spec value" id="val-mk_edge"><a href="#val-mk_edge" class="anchor"></a><code><span class="keyword">val</span> mk_edge : <a href="index.html#type-context">context</a> <span>&#45;&gt;</span> int <span>&#45;&gt;</span> int <span>&#45;&gt;</span> <span><span class="type-var">'a</span> <a href="index.html#type-t">t</a></span></code></dt><dt class="spec value" id="val-mk_segment"><a href="#val-mk_segment" class="anchor"></a><code><span class="keyword">val</span> mk_segment : <a href="index.html#type-context">context</a> <span>&#45;&gt;</span> <span><span class="type-var">'a</span> <a href="index.html#type-t">t</a></span> <span>&#45;&gt;</span> <span><a href="index.html#type-nested">nested</a> <a href="index.html#type-t">t</a></span></code></dt><dt class="spec value" id="val-promote"><a href="#val-promote" class="anchor"></a><code><span class="keyword">val</span> promote : <span><a href="index.html#type-simple">simple</a> <a href="index.html#type-t">t</a></span> <span>&#45;&gt;</span> <span><a href="index.html#type-nested">nested</a> <a href="index.html#type-t">t</a></span></code></dt><dd><p>Cast a simple path expression to a nested path expression.</p></dd></dl></section><section><header><h3 id="evaluation"><a href="#evaluation" class="anchor"></a>Evaluation</h3></header><dl><dt class="spec type" id="type-open_pathexpr"><a href="#type-open_pathexpr" class="anchor"></a><code><span class="keyword">type</span> <span>'a open_pathexpr</span></code> = <code>[ </code><table class="variant"><tr id="type-open_pathexpr.Edge" class="anchored"><td class="def constructor"><a href="#type-open_pathexpr.Edge" class="anchor"></a><code>| </code><code>`Edge <span class="keyword">of</span> int * int</code></td></tr><tr id="type-open_pathexpr.Mul" class="anchored"><td class="def constructor"><a href="#type-open_pathexpr.Mul" class="anchor"></a><code>| </code><code>`Mul <span class="keyword">of</span> <span class="type-var">'a</span> * <span class="type-var">'a</span></code></td></tr><tr id="type-open_pathexpr.Add" class="anchored"><td class="def constructor"><a href="#type-open_pathexpr.Add" class="anchor"></a><code>| </code><code>`Add <span class="keyword">of</span> <span class="type-var">'a</span> * <span class="type-var">'a</span></code></td></tr><tr id="type-open_pathexpr.Star" class="anchored"><td class="def constructor"><a href="#type-open_pathexpr.Star" class="anchor"></a><code>| </code><code>`Star <span class="keyword">of</span> <span class="type-var">'a</span></code></td></tr><tr id="type-open_pathexpr.Zero" class="anchored"><td class="def constructor"><a href="#type-open_pathexpr.Zero" class="anchor"></a><code>| </code><code>`Zero</code></td></tr><tr id="type-open_pathexpr.One" class="anchored"><td class="def constructor"><a href="#type-open_pathexpr.One" class="anchor"></a><code>| </code><code>`One</code></td></tr></table><code> ]</code></dt><dt class="spec type" id="type-open_nested_pathexpr"><a href="#type-open_nested_pathexpr" class="anchor"></a><code><span class="keyword">type</span> <span>'a open_nested_pathexpr</span></code> = <code>[ </code><table class="variant"><tr id="type-open_nested_pathexpr.Segment" class="anchored"><td class="def constructor"><a href="#type-open_nested_pathexpr.Segment" class="anchor"></a><code>| </code><code>`Segment <span class="keyword">of</span> <span class="type-var">'a</span></code></td></tr><tr id="type-open_nested_pathexpr.open_pathexpr" class="anchored"><td class="def type"><a href="#type-open_nested_pathexpr.open_pathexpr" class="anchor"></a><code>| </code><code><span><span class="type-var">'a</span> <a href="index.html#type-open_pathexpr">open_pathexpr</a></span></code></td></tr></table><code> ]</code></dt><dt class="spec type" id="type-algebra"><a href="#type-algebra" class="anchor"></a><code><span class="keyword">type</span> <span>'a algebra</span></code><code> = <span><span class="type-var">'a</span> <a href="index.html#type-open_pathexpr">open_pathexpr</a></span> <span>&#45;&gt;</span> <span class="type-var">'a</span></code></dt><dd><p>An algebra is a structure equiped with operations for interpreting each path expression operation.</p></dd></dl><dl><dt class="spec type" id="type-nested_algebra"><a href="#type-nested_algebra" class="anchor"></a><code><span class="keyword">type</span> <span>'a nested_algebra</span></code><code> = <span><span class="type-var">'a</span> <a href="index.html#type-open_nested_pathexpr">open_nested_pathexpr</a></span> <span>&#45;&gt;</span> <span class="type-var">'a</span></code></dt><dd><p>An nested algebra is a structure equiped with operations for interpreting each nested path expression operation.</p></dd></dl><dl><dt class="spec type" id="type-table"><a href="#type-table" class="anchor"></a><code><span class="keyword">type</span> <span>'a table</span></code></dt><dd><p>Memo table for weight homomorphisms</p></dd></dl><dl><dt class="spec value" id="val-mk_table"><a href="#val-mk_table" class="anchor"></a><code><span class="keyword">val</span> mk_table : <span>?&#8288;size:int</span> <span>&#45;&gt;</span> unit <span>&#45;&gt;</span> <span><span class="type-var">'a</span> <a href="index.html#type-table">table</a></span></code></dt><dd><p>Create a new memo table</p></dd></dl><dl><dt class="spec value" id="val-eval"><a href="#val-eval" class="anchor"></a><code><span class="keyword">val</span> eval : <span>?&#8288;table:<span><span class="type-var">'a</span> <a href="index.html#type-table">table</a></span></span> <span>&#45;&gt;</span> <span>algebra:<span>(<span>[&gt; <span><span class="type-var">'a</span> <a href="index.html#type-open_pathexpr">open_pathexpr</a></span> ]</span> <span>&#45;&gt;</span> <span class="type-var">'a</span>)</span></span> <span>&#45;&gt;</span> <span><a href="index.html#type-simple">simple</a> <a href="index.html#type-t">t</a></span> <span>&#45;&gt;</span> <span class="type-var">'a</span></code></dt><dd><p>Evaluate a path expression within some other algebra. Recursive calls to <code>eval</code> are memoized so that repeated sub-path expressions are evaluated only once. The optional <code>table</code> parameter allows calls to be memoized over multiple top-level calls.</p></dd></dl><dl><dt class="spec value" id="val-eval_nested"><a href="#val-eval_nested" class="anchor"></a><code><span class="keyword">val</span> eval_nested : <span>?&#8288;table:<span><span class="type-var">'a</span> <a href="index.html#type-table">table</a></span></span> <span>&#45;&gt;</span> <span>algebra:<span>(<span>[&gt; <span><span class="type-var">'a</span> <a href="index.html#type-open_nested_pathexpr">open_nested_pathexpr</a></span> ]</span> <span>&#45;&gt;</span> <span class="type-var">'a</span>)</span></span> <span>&#45;&gt;</span> <span><a href="index.html#type-nested">nested</a> <a href="index.html#type-t">t</a></span> <span>&#45;&gt;</span> <span class="type-var">'a</span></code></dt><dt class="spec value" id="val-forget"><a href="#val-forget" class="anchor"></a><code><span class="keyword">val</span> forget : <span><span class="type-var">'a</span> <a href="index.html#type-table">table</a></span> <span>&#45;&gt;</span> <span>(int <span>&#45;&gt;</span> int <span>&#45;&gt;</span> bool)</span> <span>&#45;&gt;</span> unit</code></dt><dd><p>Forget memoized values for path expressions that involve edges that do not satisfy the given predicate.</p></dd></dl></section></section><section><header><h2 id="omega-path-expressions"><a href="#omega-path-expressions" class="anchor"></a>Omega path expressions</h2></header><dl><dt class="spec type" id="type-omega"><a href="#type-omega" class="anchor"></a><code><span class="keyword">type</span> <span>'a omega</span></code></dt><dd><p>An omega path expression for a graph <code>G</code> is an omega regular expression over the alphabet of the edges of <code>G</code>, in which every recognized omega word is an infinite path in <code>G</code></p></dd></dl><dl><dt class="spec value" id="val-pp_omega"><a href="#val-pp_omega" class="anchor"></a><code><span class="keyword">val</span> pp_omega : Stdlib.Format.formatter <span>&#45;&gt;</span> <span><span class="type-var">'a</span> <a href="index.html#type-omega">omega</a></span> <span>&#45;&gt;</span> unit</code></dt><dt class="spec value" id="val-show_omega"><a href="#val-show_omega" class="anchor"></a><code><span class="keyword">val</span> show_omega : <span><span class="type-var">'a</span> <a href="index.html#type-omega">omega</a></span> <span>&#45;&gt;</span> string</code></dt></dl><section><header><h3 id="constructors"><a href="#constructors" class="anchor"></a>Constructors</h3></header><dl><dt class="spec value" id="val-mk_omega"><a href="#val-mk_omega" class="anchor"></a><code><span class="keyword">val</span> mk_omega : <a href="index.html#type-context">context</a> <span>&#45;&gt;</span> <span><span class="type-var">'a</span> <a href="index.html#type-t">t</a></span> <span>&#45;&gt;</span> <span><span class="type-var">'a</span> <a href="index.html#type-omega">omega</a></span></code></dt><dt class="spec value" id="val-mk_omega_add"><a href="#val-mk_omega_add" class="anchor"></a><code><span class="keyword">val</span> mk_omega_add : <a href="index.html#type-context">context</a> <span>&#45;&gt;</span> <span><span class="type-var">'a</span> <a href="index.html#type-omega">omega</a></span> <span>&#45;&gt;</span> <span><span class="type-var">'a</span> <a href="index.html#type-omega">omega</a></span> <span>&#45;&gt;</span> <span><span class="type-var">'a</span> <a href="index.html#type-omega">omega</a></span></code></dt><dt class="spec value" id="val-mk_omega_mul"><a href="#val-mk_omega_mul" class="anchor"></a><code><span class="keyword">val</span> mk_omega_mul : <a href="index.html#type-context">context</a> <span>&#45;&gt;</span> <span><span class="type-var">'a</span> <a href="index.html#type-t">t</a></span> <span>&#45;&gt;</span> <span><span class="type-var">'a</span> <a href="index.html#type-omega">omega</a></span> <span>&#45;&gt;</span> <span><span class="type-var">'a</span> <a href="index.html#type-omega">omega</a></span></code></dt><dt class="spec value" id="val-promote_omega"><a href="#val-promote_omega" class="anchor"></a><code><span class="keyword">val</span> promote_omega : <span><a href="index.html#type-simple">simple</a> <a href="index.html#type-omega">omega</a></span> <span>&#45;&gt;</span> <span><a href="index.html#type-nested">nested</a> <a href="index.html#type-omega">omega</a></span></code></dt><dd><p>Cast a simple omega path expression to a nested omega path expression.</p></dd></dl></section><section><header><h3 id="evaluation"><a href="#evaluation" class="anchor"></a>Evaluation</h3></header><dl><dt class="spec type" id="type-open_omega_pathexpr"><a href="#type-open_omega_pathexpr" class="anchor"></a><code><span class="keyword">type</span> <span>('a, 'b) open_omega_pathexpr</span></code> = <code>[ </code><table class="variant"><tr id="type-open_omega_pathexpr.Omega" class="anchored"><td class="def constructor"><a href="#type-open_omega_pathexpr.Omega" class="anchor"></a><code>| </code><code>`Omega <span class="keyword">of</span> <span class="type-var">'a</span></code></td></tr><tr id="type-open_omega_pathexpr.Mul" class="anchored"><td class="def constructor"><a href="#type-open_omega_pathexpr.Mul" class="anchor"></a><code>| </code><code>`Mul <span class="keyword">of</span> <span class="type-var">'a</span> * <span class="type-var">'b</span></code></td></tr><tr id="type-open_omega_pathexpr.Add" class="anchored"><td class="def constructor"><a href="#type-open_omega_pathexpr.Add" class="anchor"></a><code>| </code><code>`Add <span class="keyword">of</span> <span class="type-var">'b</span> * <span class="type-var">'b</span></code></td></tr></table><code> ]</code></dt><dt class="spec type" id="type-omega_algebra"><a href="#type-omega_algebra" class="anchor"></a><code><span class="keyword">type</span> <span>('a, 'b) omega_algebra</span></code><code> = <span><span>(<span class="type-var">'a</span>,Â <span class="type-var">'b</span>)</span> <a href="index.html#type-open_omega_pathexpr">open_omega_pathexpr</a></span> <span>&#45;&gt;</span> <span class="type-var">'b</span></code></dt><dd><p>An omega algebra is a structure equiped with operations for interpreting each omega path expression operation.</p></dd></dl><dl><dt class="spec type" id="type-omega_table"><a href="#type-omega_table" class="anchor"></a><code><span class="keyword">type</span> <span>('a, 'b) omega_table</span></code></dt><dd><p>Memo table for omega weight homomorphisms</p></dd></dl><dl><dt class="spec value" id="val-mk_omega_table"><a href="#val-mk_omega_table" class="anchor"></a><code><span class="keyword">val</span> mk_omega_table : <span>?&#8288;size:int</span> <span>&#45;&gt;</span> <span><span class="type-var">'a</span> <a href="index.html#type-table">table</a></span> <span>&#45;&gt;</span> <span><span>(<span class="type-var">'a</span>,Â <span class="type-var">'b</span>)</span> <a href="index.html#type-omega_table">omega_table</a></span></code></dt><dd><p>Create a new omega memo table</p></dd></dl><dl><dt class="spec value" id="val-eval_omega"><a href="#val-eval_omega" class="anchor"></a><code><span class="keyword">val</span> eval_omega : <span>?&#8288;table:<span><span>(<span class="type-var">'a</span>,Â <span class="type-var">'b</span>)</span> <a href="index.html#type-omega_table">omega_table</a></span></span> <span>&#45;&gt;</span> <span>algebra:<span><span class="type-var">'a</span> <a href="index.html#type-nested_algebra">nested_algebra</a></span></span> <span>&#45;&gt;</span> <span>omega_algebra:<span><span>(<span class="type-var">'a</span>,Â <span class="type-var">'b</span>)</span> <a href="index.html#type-omega_algebra">omega_algebra</a></span></span> <span>&#45;&gt;</span> <span><a href="index.html#type-nested">nested</a> <a href="index.html#type-omega">omega</a></span> <span>&#45;&gt;</span> <span class="type-var">'b</span></code></dt><dd><p>Evaluate an omega path expression within some other algebra. Recursive calls to <code>eval_omega</code> are memoized so that repeated sub-path expressions are evaluated only once. The optional <code>table</code> parameter allows calls to be memoized over multiple top-level calls.</p></dd></dl></section></section></div></body></html>