(** Ideal in Q[X,X'] representing an algebraic transition system *)

open Syntax

type t

(** Map Q^n -> Q^n defined by an array of polynomials
     p_0(x_0,...,x_{n-1})
     ...
     p_{n-1}(x_0,...,x_{n-1}) *)
type polynomial_map = Polynomial.QQXs.t array

type block =
  { blk_transform : QQ.t array array;
    blk_add : Polynomial.QQXs.t array }

(** A solvable polynomial map is a list of blocks representing a function
    x_0' = A_1*x_0 + p_0()
    x_1' = A_2*x_1 + p_1(x_0)
    ...
    x_m' = A_m*x_m + p_m(x_0,...,x_{m-1})

    where each A_i is a rational matrix and each p_i is a vector of
    polynomials over the variables of lower blocks. *)
type solvable_polynomial = block list

(** [make n qs] creates a transition ideal of dimension [n] generated by the
   polynomials [qs].  Variables in [0 .. n -1] correspond to pre-state
   variables, and variables in [ n .. 2*n - 1] correspond to post-state
   variables. *)
val make : int -> Polynomial.Rewrite.t -> t

(** [of_tf_polynomials qs tr_symbols] creates a transition ideal of dimension
   [length tr_symbols] generated by the polynomials [qs].  Variables in [map
   fst tr_symbols] correspond to pre-state variables, and variables in [map
   snd tr_symbols] correspond to post-state variables; these polynomials are
   translated into the vocabulary [0 .. 2n-1].  **)
val of_tf_polynomials : Polynomial.QQXs.t list -> (symbol * symbol) list -> t

val pp : (Format.formatter -> int -> unit) -> Format.formatter -> t -> unit

val pp_sp : Format.formatter -> solvable_polynomial -> unit

val equal : t -> t -> bool

(** Sequential composition *)
val compose : t -> t -> t

(** [image I f n] is the image of a transition under the polynomial map f: {
   \overline{f}(p) : p \in I }, where \overline{f} denotes the extension of
   the map f : Q[X] -> Q[Y] to Q[X,X'] -> Q[Y,Y'].  n is the dimension of the
   target space. *)
val image : t -> polynomial_map -> int -> t

(** [inverse_image f I] is the inverse image of I under the polynomial map f:
   { p : \overline{f}(p) \in I }, where \overline{f} denotes the extension of
   the map f : Q[Y] -> Q[X] to Q[Y,Y'] -> Q[X,X']. *)
val inverse_image : t -> polynomial_map -> t

(** [domain I] is the restriction of I to pre-state variables *)
val domain : t -> Polynomial.Rewrite.t

(** [invariant_domain I] is the the limit of the ascending sequence
       dom(I)  dom(I o I) dom(I o I o I) ... *)
val invariant_domain : t -> Polynomial.Rewrite.t

(** Repeatly compose a transition ideal with itself until the domain
   stabilizes; return both iteration sequence and the invariant domain of the
   transition ideal

   We have dom(I) <= dom(I o I) <= dom(I o I o I) <= ...  and there is
    some (least) n such that dom(I^n) = dom(I^m) for all m >= n.  The pair
    returned by [iteration_sequence I] is [([I; I o I; ...; I^n], dom(I^n))].
*)
val iteration_sequence : t -> (t list) * Polynomial.Rewrite.t

(** [solvable_reflection I] finds the best solvable abstraction of a
   transition ideal, along with its solvability witness.  *)
val solvable_reflection : t -> t * polynomial_map * solvable_polynomial

(** [ultimately_solvable_reflection I] finds the best ultimately solvable
   abstraction of a transition ideal, along with its solvability witness.  *)
val ultimately_solvable_reflection : t -> t * polynomial_map * solvable_polynomial

(** [solvable_witness I] finds a simulating solvable polynomial map.  The
   rowspace of the simulation is maximal, but the solvable map is not
   unique. *)
val solvable_witness : t -> solvable_polynomial * polynomial_map

(** [periodic_rational_solvable_witness I] finds a simulating solvable
   polynomial map with periodic rational eigenvalues.  The rowspace of the
   simulation is maximal, but the solvable map is not unique. *)
val periodic_rational_solvable_witness : t -> solvable_polynomial * polynomial_map

(** [universal_degree_limited I d] finds transition ideal [I'] simulating [I]
   with a degree-d polynomial simulation, such that any other (degree d)
   simulating transition ideal factors through [I'] (uniquely). *)
val universal_degree_limited : t -> int -> t * polynomial_map
val affine_degree_limited : t -> int -> t * polynomial_map

val compose_polynomial_map : polynomial_map -> polynomial_map -> polynomial_map

(** Test if a polynomial belongs to the given transition ideal *)
val mem : t -> Polynomial.QQXs.t -> bool

val get_ideal : t -> Polynomial.Rewrite.t
val get_dim : t -> int
