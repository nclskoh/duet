

module type Order = sig
  (** Type for ideals of orders.*)
  type ideal

  (** Elements of the order are Z vectors of size rank. *)
  type elem = ZZ.t array

  (** Convenient translation from integer matrix to an ideal.*)
  val idealify : ZZ.t array array -> ideal

  (** Pretty printer for ideals*)
  val pp_i : Format.formatter -> ideal -> unit
  
  (** Tests if two ideals are the same.*)
  val equal_i : ideal -> ideal -> bool

  val sum_i : ideal -> ideal -> ideal
  
  val mul_i : ideal -> ideal -> ideal

  (** Get the ideal generated by an elem.*)
  val ideal_generated_by : ZZ.t array -> ideal

  (** The ideal generated by 1.*)
  val one_i : ideal

  val intersect_i : ideal -> ideal -> ideal

  (** I : J = {x \in O : xJ \subseteq I }. *)
  val quotient_i : ideal -> ideal -> ideal

  (** Given an ideal, get the smallest positive integer that is a member of that ideal.*)
  val get_smallest_int : ideal -> ZZ.t

  (** Fractional ideals of the order. A fractional ideal consists of an integer d and and ideal
      i. The elements of the fractional ideal are the elements of i divided by d.*)
  type frac_ideal

  (** The fractional ideal generated by 1.*)
  val one : frac_ideal
  
  val sum : frac_ideal -> frac_ideal -> frac_ideal
 
  val intersect : frac_ideal -> frac_ideal -> frac_ideal

  val mul : frac_ideal -> frac_ideal -> frac_ideal

  val exp : frac_ideal -> int -> frac_ideal

  (** I :_K J = {x \in K : xJ \subseteq I } where K is the respective number field. *)
  val quotient : frac_ideal -> frac_ideal -> frac_ideal

  val pp : Format.formatter -> frac_ideal -> unit

  val equal : frac_ideal -> frac_ideal -> bool
  
  val subset : frac_ideal -> frac_ideal -> bool

  val make_frac_ideal : ZZ.t -> ideal -> frac_ideal

  (** Given an overorder o, represented as a fractional ideal, and a fractional ideal
      compute an overorder C and fractional ideal J such that J is invertible in C.*)
  val compute_overorder : frac_ideal -> frac_ideal -> frac_ideal * frac_ideal

  (** The algorithm of Ge (1993). Given ideals I_1, ..., I_k of the order
      computes an overorder C, proper invertible ideals J_1, ..., J_l of C, and
      integers e_1, ..., e_l, such that J_i + J_j = C for i <> j, and 
      (I_1C)...(I_kC) = J_1^e_1...J_l^e_l*)
  val factor_refinement : frac_ideal list -> frac_ideal * (frac_ideal * int) list

  (** Given ideals I_1, ..., I_k of the order. Computes \[\[f_11; ...; f_1l\];
                                                          \[f_21; ...; f_2l\];
                                                          \[...\]
                                                          \[f_k1; ...; f_kl\]\], 
      ideals J_1, ..., J_l of overorder C, such that I_iC = J_1^f_i1...J_l^f_il.*)
  val compute_factorization : frac_ideal list -> int list list * frac_ideal list * frac_ideal
  
  (** Given elements gamma_1, ..., gamma_k of the order, computes a basis
                                                          \[\[f_11; ...; f_1k\];
                                                          \[f_21; ...; f_2k\];
                                                          \[...\]
                                                          \[f_l1; ...; f_lk\]\]
      for the set {n_1, ..., n_k : gamma_1^n_1...gamma_k^n_k is a unit of O.} *)
  val find_unit_basis : ZZ.t array list -> int list list
end



(** Functor for creating an order of a number field. An order in a number field is a finite 
    dimensional Z module with compatible multiplication to make an order a ring. Let 1,e_1,...,e_{n-1}
    be a basis for the order as a Z module. Then the rank of the order is n. Elements of the
    order are integer combinations of 1,e_2,...,e_n. Therfore, elements of the order are
    represented by integer arrays of size n. For implementation reasons we assume the constant
    dimension 1 is the rightmost dimension. That is, if e_1,...,e_{n-1}, 1 is a basis for an 
    order the element a + be_{n-1} could be represented by \[|0, 0, ..., b, a|\]. The order of
    the other dimensions doesn't matter.*)
module MakeOrder(A : sig
    (** The rank of the number field. *)
    val rank : int

    (** The multiplication table for the order. [mult i j] needs to be defined for 0<=i<rank and
        0<=j<rank. Then [mult i j] = \[|a_1, ..., a_{rank}|\] should correspond to
        e_ie_j = a_1e_1 + ... + a_{rank-1}e_{n-1} a_{rank}.*)
    val mult : int -> int -> ZZ.t array

  end) : Order
