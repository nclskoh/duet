<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml"><head><title>Srk__Quantifier (srk.Srk__Quantifier)</title><link rel="stylesheet" href="../../odoc.css"/><meta charset="utf-8"/><meta name="generator" content="odoc 1.5.0"/><meta name="viewport" content="width=device-width,initial-scale=1.0"/><script src="../../highlight.pack.js"></script><script>hljs.initHighlightingOnLoad();</script></head><body><div class="content"><header><nav><a href="../index.html">Up</a> â€“ <a href="../index.html">srk</a> &#x00BB; Srk__Quantifier</nav><h1>Module <code>Srk__Quantifier</code></h1></header><dl><dt class="spec value" id="val-simsat"><a href="#val-simsat" class="anchor"></a><code><span class="keyword">val</span> simsat : <span><span class="type-var">'a</span> <a href="../Srk/Syntax/index.html#type-context">Srk.Syntax.context</a></span> <span>&#45;&gt;</span> <span><span class="type-var">'a</span> <a href="../Srk/Syntax/index.html#type-formula">Srk.Syntax.formula</a></span> <span>&#45;&gt;</span> <span>[ `Sat <span>| `Unsat</span> <span>| `Unknown</span> ]</span></code></dt><dd><p>Satisfiability via strategy improvement</p></dd></dl><dl><dt class="spec value" id="val-simsat_forward"><a href="#val-simsat_forward" class="anchor"></a><code><span class="keyword">val</span> simsat_forward : <span><span class="type-var">'a</span> <a href="../Srk/Syntax/index.html#type-context">Srk.Syntax.context</a></span> <span>&#45;&gt;</span> <span><span class="type-var">'a</span> <a href="../Srk/Syntax/index.html#type-formula">Srk.Syntax.formula</a></span> <span>&#45;&gt;</span> <span>[ `Sat <span>| `Unsat</span> <span>| `Unknown</span> ]</span></code></dt><dd><p>Satisfiability via strategy improvement, forwards version</p></dd></dl><dl><dt class="spec value" id="val-maximize"><a href="#val-maximize" class="anchor"></a><code><span class="keyword">val</span> maximize : <span><span class="type-var">'a</span> <a href="../Srk/Syntax/index.html#type-context">Srk.Syntax.context</a></span> <span>&#45;&gt;</span> <span><span class="type-var">'a</span> <a href="../Srk/Syntax/index.html#type-formula">Srk.Syntax.formula</a></span> <span>&#45;&gt;</span> <span><span class="type-var">'a</span> <a href="../Srk/Syntax/index.html#type-term">Srk.Syntax.term</a></span> <span>&#45;&gt;</span> <span>[ <span>`Bounded of <a href="../Srk/QQ/index.html#type-t">Srk.QQ.t</a></span> <span>| `Infinity</span> <span>| `MinusInfinity</span> <span>| `Unknown</span> ]</span></code></dt><dd><p>Alternating quantifier optimization</p></dd></dl><dl><dt class="spec value" id="val-qe_mbp"><a href="#val-qe_mbp" class="anchor"></a><code><span class="keyword">val</span> qe_mbp : <span><span class="type-var">'a</span> <a href="../Srk/Syntax/index.html#type-context">Srk.Syntax.context</a></span> <span>&#45;&gt;</span> <span><span class="type-var">'a</span> <a href="../Srk/Syntax/index.html#type-formula">Srk.Syntax.formula</a></span> <span>&#45;&gt;</span> <span><span class="type-var">'a</span> <a href="../Srk/Syntax/index.html#type-formula">Srk.Syntax.formula</a></span></code></dt><dd><p>Quantifier eliminiation via model-based projection</p></dd></dl><dl><dt class="spec value" id="val-mbp"><a href="#val-mbp" class="anchor"></a><code><span class="keyword">val</span> mbp : <span>?&#8288;dnf:bool</span> <span>&#45;&gt;</span> <span><span class="type-var">'a</span> <a href="../Srk/Syntax/index.html#type-context">Srk.Syntax.context</a></span> <span>&#45;&gt;</span> <span>(<a href="../Srk/Syntax/index.html#type-symbol">Srk.Syntax.symbol</a> <span>&#45;&gt;</span> bool)</span> <span>&#45;&gt;</span> <span><span class="type-var">'a</span> <a href="../Srk/Syntax/index.html#type-formula">Srk.Syntax.formula</a></span> <span>&#45;&gt;</span> <span><span class="type-var">'a</span> <a href="../Srk/Syntax/index.html#type-formula">Srk.Syntax.formula</a></span></code></dt><dd><p>Model-based projection. If <code>dnf</code> option is set, convert to disjunctive normal form.</p></dd></dl><dl><dt class="spec value" id="val-mbp_cover"><a href="#val-mbp_cover" class="anchor"></a><code><span class="keyword">val</span> mbp_cover : <span>?&#8288;dnf:bool</span> <span>&#45;&gt;</span> <span><span class="type-var">'a</span> <a href="../Srk/Syntax/index.html#type-context">Srk.Syntax.context</a></span> <span>&#45;&gt;</span> <span>(<a href="../Srk/Syntax/index.html#type-symbol">Srk.Syntax.symbol</a> <span>&#45;&gt;</span> bool)</span> <span>&#45;&gt;</span> <span><span class="type-var">'a</span> <a href="../Srk/Syntax/index.html#type-formula">Srk.Syntax.formula</a></span> <span>&#45;&gt;</span> <span><span class="type-var">'a</span> <a href="../Srk/Syntax/index.html#type-formula">Srk.Syntax.formula</a></span></code></dt><dd><p>Over-approximtate model-based projection. If <code>dnf</code> option is set, convert to disjunctive normal form.</p></dd></dl><dl><dt class="spec value" id="val-easy_sat"><a href="#val-easy_sat" class="anchor"></a><code><span class="keyword">val</span> easy_sat : <span><span class="type-var">'a</span> <a href="../Srk/Syntax/index.html#type-context">Srk.Syntax.context</a></span> <span>&#45;&gt;</span> <span><span class="type-var">'a</span> <a href="../Srk/Syntax/index.html#type-formula">Srk.Syntax.formula</a></span> <span>&#45;&gt;</span> <span>[ `Sat <span>| `Unsat</span> <span>| `Unknown</span> ]</span></code></dt><dd><p>Alternating quantifier satisfiability</p></dd></dl><dl><dt class="spec type" id="type-strategy"><a href="#type-strategy" class="anchor"></a><code><span class="keyword">type</span> <span>'a strategy</span></code></dt><dt class="spec type" id="type-quantifier_prefix"><a href="#type-quantifier_prefix" class="anchor"></a><code><span class="keyword">type</span> quantifier_prefix</code><code> = <span><span>(<span>[ `Forall <span>| `Exists</span> ]</span> * <a href="../Srk/Syntax/index.html#type-symbol">Srk.Syntax.symbol</a>)</span> list</span></code></dt></dl><dl><dt class="spec value" id="val-pp_strategy"><a href="#val-pp_strategy" class="anchor"></a><code><span class="keyword">val</span> pp_strategy : <span><span class="type-var">'a</span> <a href="../Srk/Syntax/index.html#type-context">Srk.Syntax.context</a></span> <span>&#45;&gt;</span> Stdlib.Format.formatter <span>&#45;&gt;</span> <span><span class="type-var">'a</span> <a href="index.html#type-strategy">strategy</a></span> <span>&#45;&gt;</span> unit</code></dt><dt class="spec value" id="val-show_strategy"><a href="#val-show_strategy" class="anchor"></a><code><span class="keyword">val</span> show_strategy : <span><span class="type-var">'a</span> <a href="../Srk/Syntax/index.html#type-context">Srk.Syntax.context</a></span> <span>&#45;&gt;</span> <span><span class="type-var">'a</span> <a href="index.html#type-strategy">strategy</a></span> <span>&#45;&gt;</span> string</code></dt><dt class="spec value" id="val-winning_strategy"><a href="#val-winning_strategy" class="anchor"></a><code><span class="keyword">val</span> winning_strategy : <span><span class="type-var">'a</span> <a href="../Srk/Syntax/index.html#type-context">Srk.Syntax.context</a></span> <span>&#45;&gt;</span> <a href="index.html#type-quantifier_prefix">quantifier_prefix</a> <span>&#45;&gt;</span> <span><span class="type-var">'a</span> <a href="../Srk/Syntax/index.html#type-formula">Srk.Syntax.formula</a></span> <span>&#45;&gt;</span> <span>[ <span>`Sat of <span><span class="type-var">'a</span> <a href="index.html#type-strategy">strategy</a></span></span> <span><span>| `Unsat</span> of <span><span class="type-var">'a</span> <a href="index.html#type-strategy">strategy</a></span></span> <span>| `Unknown</span> ]</span></code></dt><dd><p>Compute a winning SAT/UNSAT strategy for a formula. The formula is represented in prenex form (quantifier prefix + matrix).</p></dd></dl><dl><dt class="spec value" id="val-check_strategy"><a href="#val-check_strategy" class="anchor"></a><code><span class="keyword">val</span> check_strategy : <span><span class="type-var">'a</span> <a href="../Srk/Syntax/index.html#type-context">Srk.Syntax.context</a></span> <span>&#45;&gt;</span> <a href="index.html#type-quantifier_prefix">quantifier_prefix</a> <span>&#45;&gt;</span> <span><span class="type-var">'a</span> <a href="../Srk/Syntax/index.html#type-formula">Srk.Syntax.formula</a></span> <span>&#45;&gt;</span> <span><span class="type-var">'a</span> <a href="index.html#type-strategy">strategy</a></span> <span>&#45;&gt;</span> bool</code></dt><dd><p>Verify that a SAT strategy is in fact a winning strategy. (To verify an UNSAT strategy, just negate the formula &amp; quantifier prefix)</p></dd></dl><dl><dt class="spec value" id="val-normalize"><a href="#val-normalize" class="anchor"></a><code><span class="keyword">val</span> normalize : <span><span class="type-var">'a</span> <a href="../Srk/Syntax/index.html#type-context">Srk.Syntax.context</a></span> <span>&#45;&gt;</span> <span><span class="type-var">'a</span> <a href="../Srk/Syntax/index.html#type-formula">Srk.Syntax.formula</a></span> <span>&#45;&gt;</span> <a href="index.html#type-quantifier_prefix">quantifier_prefix</a> * <span><span class="type-var">'a</span> <a href="../Srk/Syntax/index.html#type-formula">Srk.Syntax.formula</a></span></code></dt><dd><p>Write a formula in prenex normal form, using constant symbols instead of variables.</p></dd></dl><dl><dt class="spec value" id="val-is_presburger_atom"><a href="#val-is_presburger_atom" class="anchor"></a><code><span class="keyword">val</span> is_presburger_atom : <span><span class="type-var">'a</span> <a href="../Srk/Syntax/index.html#type-context">Srk.Syntax.context</a></span> <span>&#45;&gt;</span> <span><span class="type-var">'a</span> <a href="../Srk/Syntax/index.html#type-formula">Srk.Syntax.formula</a></span> <span>&#45;&gt;</span> bool</code></dt><dt class="spec value" id="val-local_project_cube"><a href="#val-local_project_cube" class="anchor"></a><code><span class="keyword">val</span> local_project_cube : <span><span class="type-var">'a</span> <a href="../Srk/Syntax/index.html#type-context">Srk.Syntax.context</a></span> <span>&#45;&gt;</span> <span>(<a href="../Srk/Syntax/index.html#type-symbol">Srk.Syntax.symbol</a> <span>&#45;&gt;</span> bool)</span> <span>&#45;&gt;</span> <span><span class="type-var">'a</span> <a href="../Srk/Interpretation/index.html#type-interpretation">Srk.Interpretation.interpretation</a></span> <span>&#45;&gt;</span> <span><span><span class="type-var">'a</span> <a href="../Srk/Syntax/index.html#type-formula">Srk.Syntax.formula</a></span> list</span> <span>&#45;&gt;</span> <span><span><span class="type-var">'a</span> <a href="../Srk/Syntax/index.html#type-formula">Srk.Syntax.formula</a></span> list</span></code></dt><dd><p>Given an interpretation <code>M</code>, a conjunctive formula <code>cube</code> such that <code>M |= cube</code>, and a predicate <code>p</code>, find a cube <code>cube'</code> expressed over symbols that satisfy <code>p</code> such that <code>M |= cube' |=
   cube</code>. <code>local_project_cube</code> has a finite image in the sense that for any cube <code>c</code>, the set <code>{ local_project_cube srk p m c : m |= c
   }</code> is finite. <code>local_project_cube</code> assumes a formula in <code>QF_LRA</code>; if not, then <code>cube'</code> may not entail <code>cube</code>, but it is guaranteed to be satisfied by <code>M</code>.</p></dd></dl></div></body></html>